<?xml version="1.0" encoding="UTF-8"?>
<model version="4.2.1" links="0">
 <framework name="qpc"/>
 <package file="./TLao.qmp"/>
 <package file="./TLevt.qmp"/>
 <directory name="./Source">
  <file name="trafficlight.h">
   <text>#ifndef trafficlight_h
#define trafficlight_h

enum TLSignals {
    TIME_TICK_SIG = Q_USER_SIG, /* time ticker event */
    GLOBAL_START_SIG,
    STARTNEWCYCLE_SIG,             /* published by traffic light to start cycle */
    PEDREQUEST_SIG,       /* published by pedestrian light to start cycle */
    TL_IS_RED_SIG,
    PL_IS_RED_SIG,
    BUTTON_SIG,                 /* published by BSP to notify about pedestrian requests */
    START_BLINK_SIG,
    STOP_BLINK_SIG,
    OFF_BLINK_SIG,
    EMERGENCY_SIG,
    EM_RELEASE_SIG,
    MAX_PUBLISH_SIG,
    TIMEOUT_SIG,                /* used for time events */
    MAX_SIG                     /* the last signal */
};

typedef enum TLidentity eTLidentity_t;
typedef enum TLlight    eTLlight_t;

enum TLidentity {
    TrafficLightA = 0,
    TrafficLightB,
    PedestrianLight,
    MaxIdentity
};

enum TLlight {
    RED = 0,
    YELLOW,
    GREEN,
    NO_LIGHT
};

#define _TIMETICK_(t)    ((t) * (BSP_TICKS_PER_SEC))
#define _TIMETICKms_(t)  ((_TIMETICK_(t) / 1000u) ? (_TIMETICK_(t) / 1000u) : 1u)

/* timeout definitions */
#define T_5ms     _TIMETICKms_(5u)
#define T_10ms    _TIMETICKms_(10u)
#define T_50ms    _TIMETICKms_(50u) 
#define T_100ms   _TIMETICKms_(100u) 
#define T_250ms   _TIMETICKms_(250u) 
#define T_500ms   _TIMETICKms_(500u) 
#define T_1sec    _TIMETICKms_(1000u)
#define T_2sec    _TIMETICK_(2u)
#define T_5sec    _TIMETICK_(5u)
#define T_10sec   _TIMETICK_(10u)
#define T_15sec   _TIMETICK_(15u)
#define T_20sec   _TIMETICK_(20u)
#define T_30sec   _TIMETICK_(30u)

$declare(Events::TLevt)

/* number of traffic lights */
#define N_TL ((uint8_t)2)

$declare(AOs::TLtraffic_ctor)
$declare(AOs::AO_TLtraffic[N_TL])

$declare(AOs::TLpedestrian_ctor)
$declare(AOs::AO_TLpedestrian)

// $declare(AOs::TLbutton_ctor)
// $declare(AOs::AO_TLbutton)

$declare(AOs::TLblinker_ctor)
$declare(AOs::AO_TLblinker)

#endif /* trafficlight_h */</text>
  </file>
  <file name="TLtraffic.c">
   <text>#include &quot;qpc.h&quot;
#include &quot;trafficlight.h&quot;
#include &quot;bsp.h&quot;

Q_DEFINE_THIS_FILE

#define startTimeout(timeout)    QTimeEvt_rearm(&amp;me-&gt;timeEvt, timeout)
#define sendMessage(msg)         { QEvt *e = Q_NEW(QEvt, msg); QF_PUBLISH(e, me); }
/* helper macro to provide the ID of Philo &quot;me_&quot; */
#define TL_ID(me_)    ((eTLidentity_t)((me_) - l_traffic))

/* Active object class -----------------------------------------------------*/
$declare(AOs::TLtraffic)

/* Local objects -----------------------------------------------------------*/
static TLtraffic l_traffic[N_TL];   /* storage for all TLs */

/* Global objects ----------------------------------------------------------*/
QActive * const AO_TLtraffic[N_TL] = { /* &quot;opaque&quot; pointers to TL AO */
    &amp;l_traffic[0].super,
    &amp;l_traffic[1].super
};

/* TL definition --------------------------------------------------------*/
$define(AOs::TLtraffic_ctor)
$define(AOs::TLtraffic)
</text>
  </file>
  <file name="TLpedestrian.c">
   <text>#include &quot;qpc.h&quot;
#include &quot;trafficlight.h&quot;
#include &quot;bsp.h&quot;

Q_DEFINE_THIS_FILE

/* Active object class -----------------------------------------------------*/
$declare(AOs::TLpedestrian)

/* Local objects -----------------------------------------------------------*/
static TLpedestrian l_pedestrian;   /* storage for PL */

/* Global objects ----------------------------------------------------------*/
QActive * const AO_TLpedestrian = &amp;l_pedestrian.super;   /* &quot;opaque&quot; pointer to PL AO */

/* PL definition --------------------------------------------------------*/
$define(AOs::TLpedestrian_ctor)
$define(AOs::TLpedestrian)</text>
  </file>
  <file name="TLmain.c">
   <text>#include &quot;qpc.h&quot;
#include &quot;trafficlight.h&quot;
#include &quot;bsp.h&quot;

/* &quot;fudge factor&quot; for Windows, see NOTE1 */
#if defined WIN32
#define WIN_FUDGE   10
#else
#define WIN_FUDGE    1
#endif
enum { WIN_FUDGE_FACTOR = WIN_FUDGE };

static QTicker l_ticker0;
QActive *the_Ticker0 = &amp;l_ticker0;

/*..........................................................................*/
#if defined(QWIN_GUI)
#ifdef main
#undef main
#endif

#define main main_gui
int main_gui(int argc, char *argv[]);
#endif
int main(int argc, char *argv[])
{
    static QEvt const *trafficQueueSto[N_TL][5 * WIN_FUDGE_FACTOR];
    static QEvt const *pedestrianQueueSto[5 * WIN_FUDGE_FACTOR];
    static QEvt const *blinkerQueueSto[5 * WIN_FUDGE_FACTOR];
    static QSubscrList subscrSto[MAX_PUBLISH_SIG];
    static QF_MPOOL_EL(QEvt) smlPoolSto[10 * WIN_FUDGE_FACTOR];
    uint8_t n;
    uint_fast8_t aoPrio;

    TLtraffic_ctor(); /* instantiate all Philosopher active objects */
    TLpedestrian_ctor(); /* instantiate the Table active object */
    TLblinker_ctor();
    QTicker_ctor(&amp;l_ticker0, 0U); /* ticker AO for tick rate 0 */

    QF_init();    /* initialize the framework and the underlying RT kernel */
    BSP_init(argc, argv); /* initialize the Board Support Package */

    /* object dictionaries... */
    QS_OBJ_DICTIONARY(smlPoolSto);
    QS_OBJ_DICTIONARY(pedestrianQueueSto);
    QS_OBJ_DICTIONARY(trafficQueueSto[0]);
    QS_OBJ_DICTIONARY(trafficQueueSto[1]);
    QS_OBJ_DICTIONARY(blinkerQueueSto);
    QS_OBJ_DICTIONARY(AO_TLtraffic[0]);
    QS_OBJ_DICTIONARY(AO_TLtraffic[1]);
    QS_OBJ_DICTIONARY(AO_TLpedestrian);
    QS_OBJ_DICTIONARY(AO_TLblinker);

    QS_SIG_DICTIONARY(TIME_TICK_SIG, (void *)0);
    QS_SIG_DICTIONARY(GLOBAL_START_SIG, (void *)0);
    QS_SIG_DICTIONARY(STARTNEWCYCLE_SIG, (void *)0);
    QS_SIG_DICTIONARY(PEDREQUEST_SIG, (void *)0);
    QS_SIG_DICTIONARY(TL_IS_RED_SIG, (void *)0);
    QS_SIG_DICTIONARY(PL_IS_RED_SIG, (void *)0);
    QS_SIG_DICTIONARY(BUTTON_SIG, (void *)0);
    QS_SIG_DICTIONARY(START_BLINK_SIG, (void *)0);
    QS_SIG_DICTIONARY(STOP_BLINK_SIG, (void *)0);
    QS_SIG_DICTIONARY(OFF_BLINK_SIG, (void *)0);
    QS_SIG_DICTIONARY(EMERGENCY_SIG, (void *)0);
    QS_SIG_DICTIONARY(EM_RELEASE_SIG, (void *)0);
    QS_SIG_DICTIONARY(TIMEOUT_SIG, (void *)0);

    /* initialize publish-subscribe... */
    QF_psInit(subscrSto, Q_DIM(subscrSto));

    /* initialize event pools... */
    QF_poolInit(smlPoolSto, sizeof(smlPoolSto), sizeof(smlPoolSto[0]));

    aoPrio = 1u;
    QACTIVE_START(the_Ticker0, aoPrio++, 0, 0, 0, 0, 0);

    /* start the active objects... */
    for (n = 0U; n &lt; N_TL; ++n) {
        QACTIVE_START(AO_TLtraffic[n],           /* AO to start */
                      aoPrio++, /* QP priority of the AO */
                      trafficQueueSto[n],      /* event queue storage */
                      Q_DIM(trafficQueueSto[n]), /* queue length [events] */
                      (void *)0,             /* stack storage (not used) */
                      0U,                    /* size of the stack [bytes] */
                     (QEvt *)0);             /* initialization event */
    }
    QACTIVE_START(AO_TLpedestrian,                  /* AO to start */
                  aoPrio++, /* QP priority of the AO */
                  pedestrianQueueSto,             /* event queue storage */
                  Q_DIM(pedestrianQueueSto),      /* queue length [events] */
                  (void *)0,                 /* stack storage (not used) */
                  0U,                        /* size of the stack [bytes] */
                  (QEvt *)0);                /* initialization event */
    QACTIVE_START(AO_TLblinker,                  /* AO to start */
                  aoPrio++, /* QP priority of the AO */
                  blinkerQueueSto,             /* event queue storage */
                  Q_DIM(blinkerQueueSto),      /* queue length [events] */
                  (void *)0,                 /* stack storage (not used) */
                  0U,                        /* size of the stack [bytes] */
                  (QEvt *)0);                /* initialization event */

    return QF_run(); /* run the QF application */
}

/*****************************************************************************
* NOTE1:
* Windows is not a deterministic real-time system, which means that the
* system can occasionally and unexpectedly &quot;choke and freeze&quot; for a number
* of seconds. The designers of Windows have dealt with these sort of issues
* by massively oversizing the resources available to the applications. For
* example, the default Windows GUI message queues size is 10,000 entries,
* which can dynamically grow to an even larger number. Also the stacks of
* Win32 threads can dynamically grow to several megabytes.
*
* In contrast, the event queues, event pools, and stack size inside the
* real-time embedded (RTE) systems can be (and must be) much smaller,
* because you typically can put an upper bound on the real-time behavior
* and the resulting delays.
*
* To be able to run the unmodified applications designed originally for
* RTE systems on Windows, and to reduce the odds of resource shortages in
* this case, the generous WIN_FUDGE_FACTOR is used to oversize the
* event queues and event pools.
*/</text>
  </file>
  <file name="TLblinker.c">
   <text>#include &quot;qpc.h&quot;
#include &quot;trafficlight.h&quot;
#include &quot;bsp.h&quot;

Q_DEFINE_THIS_FILE

enum {
    ledOFF = 0,
    ledON
};

#define setLEDon()   TLblinker_setLed(me, ledON)
#define setLEDoff()  TLblinker_setLed(me, ledOFF)

/* Active object class -----------------------------------------------------*/
$declare(AOs::TLblinker)

/* Local objects -----------------------------------------------------------*/
static TLblinker l_blinker;   /* storage for PL */

/* Global objects ----------------------------------------------------------*/
QActive * const AO_TLblinker = &amp;l_blinker.super;   /* &quot;opaque&quot; pointer to PL AO */

/* PL definition --------------------------------------------------------*/
$define(AOs::TLblinker_ctor)
$define(AOs::TLblinker)</text>
  </file>
 </directory>
</model>
