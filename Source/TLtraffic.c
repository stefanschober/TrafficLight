/*$file${./Source::TLtraffic.c} ############################################*/
/*
* Model: TrafficLight.qm
* File:  ${./Source::TLtraffic.c}
*
* This code has been generated by QM tool (https://state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${./Source::TLtraffic.c} #########################################*/
#include "qpc.h"
#include "trafficlight.h"
#include "bsp.h"

Q_DEFINE_THIS_FILE

#define startTimeout(timeout)    QTimeEvt_rearm(&me->timeEvt, timeout)
#define sendMessage(msg)         { QEvt *e = Q_NEW(QEvt, msg); QF_PUBLISH(e, me); }
/* helper macro to provide the ID of Philo "me_" */
#define TL_ID(me_)    ((eTLidentity_t)((me_) - l_traffic))

/* Active object class -----------------------------------------------------*/
/*$declare${AOs::TLtraffic} ################################################*/
/*${AOs::TLtraffic} ........................................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    eTLidentity_t identity;
    eTLlight_t light;
    QTimeEvt timeEvt;
} TLtraffic;

/* protected: */
static QState TLtraffic_initial(TLtraffic * const me, QEvt const * const e);
static QState TLtraffic_INIT_TL(TLtraffic * const me, QEvt const * const e);
static QState TLtraffic_GREEN(TLtraffic * const me, QEvt const * const e);
static QState TLtraffic_GREEN_1(TLtraffic * const me, QEvt const * const e);
static QState TLtraffic_GREEN_2(TLtraffic * const me, QEvt const * const e);
static QState TLtraffic_GREEN_3(TLtraffic * const me, QEvt const * const e);
static QState TLtraffic_YELLOW(TLtraffic * const me, QEvt const * const e);
static QState TLtraffic_YELLOW_1(TLtraffic * const me, QEvt const * const e);
static QState TLtraffic_YELLOW_2(TLtraffic * const me, QEvt const * const e);
static QState TLtraffic_RED(TLtraffic * const me, QEvt const * const e);
static QState TLtraffic_RED_1(TLtraffic * const me, QEvt const * const e);
static QState TLtraffic_RED_2(TLtraffic * const me, QEvt const * const e);
static QState TLtraffic_RED_3(TLtraffic * const me, QEvt const * const e);
/*$enddecl${AOs::TLtraffic} ################################################*/

/* Local objects -----------------------------------------------------------*/
static TLtraffic l_traffic[N_TL];   /* storage for all TLs */

/* Local functions */
static void setLight(TLtraffic * const me, eTLlight_t light);

/* Global objects ----------------------------------------------------------*/
QActive * const AO_TLtraffic[N_TL] = { /* "opaque" pointers to TL AO */
    &l_traffic[0].super,
    &l_traffic[1].super
};

/* TL definition --------------------------------------------------------*/
/*$define${AOs::TLtraffic_ctor} ############################################*/
/* Check for the minimum required QP version */
#if ((QP_VERSION < 601) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpc version 6.0.1 or higher required
#endif
/*${AOs::TLtraffic_ctor} ...................................................*/
void TLtraffic_ctor(void) {
    uint8_t n;

    for (n = 0; n < N_TL; n++)
    {
        TLtraffic *me = &l_traffic[n];

        QActive_ctor(&me->super, Q_STATE_CAST(&TLtraffic_initial));
        QTimeEvt_ctorX(&me->timeEvt, &me->super, TIMEOUT_SIG, 0U);
        me->identity = (eTLidentity_t)n;
        Q_ENSURE((me->identity == TrafficLightA) || (me->identity == TrafficLightB));
        me->light = RED;
    }
}
/*$enddef${AOs::TLtraffic_ctor} ############################################*/
/*$define${AOs::TLtraffic} #################################################*/
/*${AOs::TLtraffic} ........................................................*/
/*${AOs::TLtraffic::SM} ....................................................*/
static QState TLtraffic_initial(TLtraffic * const me, QEvt const * const e) {
    /*${AOs::TLtraffic::SM::initial} */
    QActive_subscribe((QActive *)me, PL_IS_RED_SIG);
    QActive_subscribe((QActive *)me, STARTNEWCYCLE_SIG);
    QActive_subscribe((QActive *)me, PEDREQUEST_SIG);
    return Q_TRAN(&TLtraffic_INIT_TL);
}
/*${AOs::TLtraffic::SM::INIT_TL} ...........................................*/
static QState TLtraffic_INIT_TL(TLtraffic * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::TLtraffic::SM::INIT_TL} */
        case Q_ENTRY_SIG: {
            setLight(me, RED);
            startTimeout(T_2sec); // was 10sec
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::TLtraffic::SM::INIT_TL::TIMEOUT} */
        case TIMEOUT_SIG: {
            /*${AOs::TLtraffic::SM::INIT_TL::TIMEOUT::[(0==TL_ID(me))]} */
            if (( 0 ==TL_ID(me) )) {
                sendMessage(GLOBAL_START_SIG);
                status_ = Q_TRAN(&TLtraffic_GREEN);
            }
            /*${AOs::TLtraffic::SM::INIT_TL::TIMEOUT::[else]} */
            else {
                status_ = Q_TRAN(&TLtraffic_RED);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::TLtraffic::SM::GREEN} .............................................*/
static QState TLtraffic_GREEN(TLtraffic * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::TLtraffic::SM::GREEN} */
        case Q_ENTRY_SIG: {
            setLight(me, GREEN);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::TLtraffic::SM::GREEN::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&TLtraffic_GREEN_1);
            break;
        }
        /*${AOs::TLtraffic::SM::GREEN::TIMEOUT,PEDREQUEST} */
        case TIMEOUT_SIG: /* intentionally fall through */
        case PEDREQUEST_SIG: {
            status_ = Q_TRAN(&TLtraffic_YELLOW);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::TLtraffic::SM::GREEN::GREEN_1} ....................................*/
static QState TLtraffic_GREEN_1(TLtraffic * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::TLtraffic::SM::GREEN::GREEN_1} */
        case Q_ENTRY_SIG: {
            startTimeout(T_5sec); // was 10s
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::TLtraffic::SM::GREEN::GREEN_1::TIMEOUT} */
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&TLtraffic_GREEN_2);
            break;
        }
        /*${AOs::TLtraffic::SM::GREEN::GREEN_1::PEDREQUEST} */
        case PEDREQUEST_SIG: {
            status_ = Q_TRAN(&TLtraffic_GREEN_3);
            break;
        }
        default: {
            status_ = Q_SUPER(&TLtraffic_GREEN);
            break;
        }
    }
    return status_;
}
/*${AOs::TLtraffic::SM::GREEN::GREEN_2} ....................................*/
static QState TLtraffic_GREEN_2(TLtraffic * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::TLtraffic::SM::GREEN::GREEN_2} */
        case Q_ENTRY_SIG: {
            startTimeout(T_5sec); // was 20s
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&TLtraffic_GREEN);
            break;
        }
    }
    return status_;
}
/*${AOs::TLtraffic::SM::GREEN::GREEN_3} ....................................*/
static QState TLtraffic_GREEN_3(TLtraffic * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&TLtraffic_GREEN);
            break;
        }
    }
    return status_;
}
/*${AOs::TLtraffic::SM::YELLOW} ............................................*/
static QState TLtraffic_YELLOW(TLtraffic * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::TLtraffic::SM::YELLOW} */
        case Q_ENTRY_SIG: {
            setLight(me, YELLOW);
            startTimeout(T_2sec); // was 5s
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::TLtraffic::SM::YELLOW::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&TLtraffic_YELLOW_1);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::TLtraffic::SM::YELLOW::YELLOW_1} ..................................*/
static QState TLtraffic_YELLOW_1(TLtraffic * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::TLtraffic::SM::YELLOW::YELLOW_1::TIMEOUT} */
        case TIMEOUT_SIG: {
            sendMessage(STARTNEWCYCLE_SIG);
            status_ = Q_TRAN(&TLtraffic_YELLOW_2);
            break;
        }
        default: {
            status_ = Q_SUPER(&TLtraffic_YELLOW);
            break;
        }
    }
    return status_;
}
/*${AOs::TLtraffic::SM::YELLOW::YELLOW_2} ..................................*/
static QState TLtraffic_YELLOW_2(TLtraffic * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::TLtraffic::SM::YELLOW::YELLOW_2::STARTNEWCYCLE} */
        case STARTNEWCYCLE_SIG: {
            status_ = Q_TRAN(&TLtraffic_RED);
            break;
        }
        default: {
            status_ = Q_SUPER(&TLtraffic_YELLOW);
            break;
        }
    }
    return status_;
}
/*${AOs::TLtraffic::SM::RED} ...............................................*/
static QState TLtraffic_RED(TLtraffic * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::TLtraffic::SM::RED} */
        case Q_ENTRY_SIG: {
            setLight(me, RED);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::TLtraffic::SM::RED::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&TLtraffic_RED_1);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::TLtraffic::SM::RED::RED_1} ........................................*/
static QState TLtraffic_RED_1(TLtraffic * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::TLtraffic::SM::RED::RED_1} */
        case Q_ENTRY_SIG: {
            sendMessage(TL_IS_RED_SIG);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::TLtraffic::SM::RED::RED_1::PEDREQUEST} */
        case PEDREQUEST_SIG: {
            status_ = Q_TRAN(&TLtraffic_RED_2);
            break;
        }
        /*${AOs::TLtraffic::SM::RED::RED_1::STARTNEWCYCLE} */
        case STARTNEWCYCLE_SIG: {
            status_ = Q_TRAN(&TLtraffic_RED_3);
            break;
        }
        default: {
            status_ = Q_SUPER(&TLtraffic_RED);
            break;
        }
    }
    return status_;
}
/*${AOs::TLtraffic::SM::RED::RED_2} ........................................*/
static QState TLtraffic_RED_2(TLtraffic * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::TLtraffic::SM::RED::RED_2} */
        case Q_ENTRY_SIG: {
            sendMessage(TL_IS_RED_SIG);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::TLtraffic::SM::RED::RED_2::PL_IS_RED} */
        case PL_IS_RED_SIG: {
            status_ = Q_TRAN(&TLtraffic_RED_3);
            break;
        }
        default: {
            status_ = Q_SUPER(&TLtraffic_RED);
            break;
        }
    }
    return status_;
}
/*${AOs::TLtraffic::SM::RED::RED_3} ........................................*/
static QState TLtraffic_RED_3(TLtraffic * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::TLtraffic::SM::RED::RED_3} */
        case Q_ENTRY_SIG: {
            startTimeout(T_2sec);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::TLtraffic::SM::RED::RED_3::TIMEOUT} */
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&TLtraffic_GREEN);
            break;
        }
        /*${AOs::TLtraffic::SM::RED::RED_3::PEDREQUEST} */
        case PEDREQUEST_SIG: {
            status_ = Q_TRAN(&TLtraffic_RED_1);
            break;
        }
        default: {
            status_ = Q_SUPER(&TLtraffic_RED);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::TLtraffic} #################################################*/

/* Local function definitions */
static void setLight(TLtraffic * const me, eTLlight_t light)
{
    me->light = light;
    BSP_setlight(me->identity, light);
}